#summary 一些常用的正则表达式

=== 中文相关 ===

匹配中文字符的正则表达式：
{{{
[\u4e00-\u9fa5]
}}}

匹配双字节字符(包括汉字在内)：
{{{
[^\x00-\xff]
}}}

应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）
{{{
String.prototype.len=function(){return this.replace([^\x00-\xff]/g,"aa").length;}
}}}

匹配空行的正则表达式：
{{{
\n[\s| ]*\r
}}}

匹配HTML标记的正则表达式：
{{{
/<(.*)>.*<\/\1>|<(.*) \/>/
}}}

匹配首尾空格的正则表达式：
{{{
(^\s*)|(\s*$)
}}}

应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：
{{{
String.prototype.trim = function(){
    return this.replace(/(^\s*)|(\s*$)/g, "");
}
}}}

===利用正则表达式分解和转换IP地址===

下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：
{{{
function IP2V(ip)
{
 re=/(\d+)\.(\d+)\.(\d+)\.(\d+)/g  //匹配IP地址的正则表达式
if(re.test(ip))
{
return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1
}
else
{
 throw new Error("Not a valid IP address!")
}
}
}}}

不过上面的程序如果不用正则表达式，而直接用split函数来分解可能更简单，程序如下：
{{{
var ip="10.100.20.168"
ip=ip.split(".")
alert("IP值是："+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1))
}}}

匹配Email地址的正则表达式：
{{{
\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*
}}}

匹配网址URL的正则表达式：
{{{
http://([\w-]+\.)+[\w-]+(/[\w- ./?%&=]*)?
}}}

利用正则表达式去除字串中重复的字符的算法程序：[注：此程序不正确，原因见本贴回复]
{{{
var s="abacabefgeeii"
var s1=s.replace(/(.).*\1/g,"$1")
var re=new RegExp("["+s1+"]","g")
var s2=s.replace(re,"") 
alert(s1+s2)  /*结果为：abcefgi */
}}}

    我原来在CSDN上发贴寻求一个表达式来实现去除重复字符的方法，最终没有找到，这是我能想到的最简单的实现方法。思路是使用后向引用取出包括重复的字符，再以重复的字符建立第二个表达式，取到不重复的字符，两者串连。这个方法对于字符顺序有要求的字符串可能不适用。

得用正则表达式从URL地址中提取文件名的javascript程序，如下结果为page1
{{{
s="http://www.9499.net/page1.htm"
s=s.replace(/(.*\/){0,}([^\.]+).*/ig,"$2")
alert(s)
}}}








===把12345678此类格式的数据换成 12,345,678 格式===

"12345678".replace(/(?=(?:\w{3})+$)/g,",") //这是网上找的一个正则，有点缺陷，在后面再修正～

这个正则是怎么进行工作的？

研究了一下，它是非常巧妙的利用?=和?:来完成匹配。
?=和?:的功能可以看下面的例子，就应该明白他们的作用了：
"IE 6,IE 7,IE 8".match(/IE (?:7|8)/gi); //["IE 7", "IE 8"]
"IE 6,IE 7,IE 8".match(/IE (?=7|8)/gi); //["IE ", "IE "]
"IE 6,IE 7,IE 8".match(/IE (?!7|8)/gi); //["IE "]，这个其实相当于匹配："IE 6,IE 7,IE 8".match(/IE (?=6)/gi);

这个正则，可以分成两部分：(?=) 和 (?:\w{3})+$
首先，(?:\w{3})+$，从最后开始匹配3的整数倍个数字；
然后，(?=)，预搜索符合上述条件的匹配：678、345678所在左侧缝隙的空字符串（"12缝隙345缝隙678"），["",""]；
最后，将匹配到的空字符串替换成","。

实际上，/(?=(?:\w{3})+$)/g 和 /(?=((?:\w{3})+$))/g 效果是一样的。

这个正则有什么缺陷？
有，比如"123456789"会被替换成",123,456,789"，多出来一个逗号。

可以这样来完善这个正则：
"123456789".replace(/(?=(?!\b)(?:\w{3})+$)/g,",")

加一个(?!\b)，让(?:\w{3})+$的匹配前面不是边界，就不会包含"123456789"了。